# ms17-010`永恒之蓝`漏洞详细分析与利用

> PS：本来5月份就该完成的总结，一直拖到现在，这种坏习惯以后得改改了。

[TOC]

## 0x00_写在前面

欢迎来到`Windows SMB协议逆向之旅`的第一篇。

ms17-010是windows平台继ms08-067之后又一个特高危smb漏洞，由于该漏洞出自于Shadow Brokers组织爆光的NSA网络武器库，几乎是指哪打哪，因此无论是危害程度还是受关注程度，可谓空前。其实当年的ms12-020也是可以RCE的，危害程度比08067更甚，只可惜没人公开POC，所以热传了一阵公众也就不再关注了，以后有时间再写写这个洞的故事。

目前国内对ms17-010的解读，主要集中在360博客播报、Freebuf和pediy论坛对漏洞函数的分析，对于新手来说，可能看起来比较费力。因此，我将采用由浅入深的方式向大家讲述一下这个漏洞的相关细节，希望能够对初入此门的童鞋有些许帮助。不足之处，敬请指正。

## 0x01_SMB协议概述

这个漏洞是怎样产生的？什么样的数据包可以触发漏洞？这可能是大多数童鞋疑问最多的地方，而对SMB协议的不熟悉，又造成了理解漏洞成因的困难。

### SMB协议的功能

简单来说，SMB协议是一个通过网络在共享文件、打印设备、命名管道、邮槽之间操作数据的协议，通过该协议客户端就可以去访问服务器上的共享文件和目录（增删改查）、打印队列和进程间通信服务等，还可以实现客户端和服务器之间的远程过程子协议的认证传输。

`备注`：邮槽是进程间通信或共享数据的一种方式，邮槽由服务端创建，客户端可以通过邮槽名打开邮槽并向邮槽中写入消息。邮槽的通信是单向的，只有服务端才能从邮槽中读取消息，客户端只能写入消息。邮槽除了在本机内进行进程间通信外，主机间也可以通信。在主机间进行邮槽通信时采用UDP协议。后续可以重点研究SMB如何以UDP方式实现邮槽的。

`备注`：管道Pipe实质上是一种共享的内存，由一个进程创建，其它进程连接，并可以进行双向通信。

> It provides clients with managed, concurrent `access to files and directories` hosted on server systems.It also provides `access to print queues and interprocess communication services`, and supports `authenticated transport for remote procedure call subprotocols`.With a few exceptions, it is `client-driven` in that a client makes requests to which a server responds.

`备注`：除了一些例外，正常情况下SMB协议是客户端驱动的。后续找时间仔细阅读协议，找出这些例外以及它们实现的功能。

为了实现上述`访问服务器上的文件、打印队列、RPC`等功能，SMB协议落实到数据包上，客户端和服务端需要基于下列数据包进行交互：

01 Session management
```c
SMB_COM_NEGOTIATE
SMB_COM_SESSION_SETUP_ANDX
SMB_COM_TREE_CONNECT
SMB_COM_TREE_CONNECT_ANDX
SMB_COM_TREE_DISCONNECT
SMB_COM_LOGOFF_ANDX
```
02 Transaction subprotocol
```c
SMB_COM_TRANSACTION
SMB_COM_TRANSACTION_SECONDARY
SMB_COM_TRANSACTION2
SMB_COM_TRANSACTION2_SECONDARY
SMB_COM_NT_TRANSACT
SMB_COM_NT_TRANSACT_SECONDARY
```
03 File/directory access methods
```c
SMB_COM_CREATE_DIRECTORY
SMB_COM_DELETE_DIRECTORY
SMB_COM_OPEN
SMB_COM_OPEN_ANDX
SMB_COM_CREATE
SMB_COM_CREATE_NEW
SMB_COM_CREATE_TEMPORARY
SMB_COM_NT_CREATE_ANDX
SMB_COM_CLOSE
SMB_COM_DELETE
```
04 Read/write/lock methods
```c
SMB_COM_FLUSH
SMB_COM_SEEK
SMB_COM_READ
SMB_COM_LOCK_AND_READ
SMB_COM_LOCK_BYTE_RANGE
SMB_COM_UNLOCK_BYTE_RANGE
SMB_COM_LOCKING_ANDX
SMB_COM_READ_ANDX
SMB_COM_READ_RAW
SMB_COM_READ_MPX
SMB_COM_WRITE
SMB_COM_WRITE_AND_CLOSE
SMB_COM_WRITE_AND_UNLOCK
SMB_COM_WRITE_ANDX
SMB_COM_WRITE_RAW
SMB_COM_WRITE_COMPLETE
SMB_COM_WRITE_MPX
```
05 Query directory information
```c
SMB_COM_CHECK_DIRECTORY
SMB_COM_SEARCH
SMB_COM_FIND
SMB_COM_FIND_UNIQUE
SMB_COM_FIND_CLOSE
SMB_COM_FIND_CLOSE2
```
06 Query/set attributes methods
```c
SMB_COM_RENAME
SMB_COM_NT_RENAME
SMB_COM_QUERY_INFORMATION
SMB_COM_SET_INFORMATION
SMB_COM_QUERY_INFORMATION_DISK
SMB_COM_QUERY_INFORMATION2
SMB_COM_SET_INFORMATION2
```
07 Printing methods
```c
SMB_COM_OPEN_PRINT_FILE
SMB_COM_WRITE_PRINT_FILE
SMB_COM_CLOSE_PRINT_FILE
```
08 Other
```c
SMB_COM_ECHO
SMB_COM_PROCESS_EXIT
SMB_COM_NT_CANCEL
SMB_COM_INVALID
SMB_COM_IOCTL
SMB_COM_NO_ANDX_COMMAND
```
除了这些数据包，还有一些被抛弃的和保留但未实现功能的数据包格式：
09 Obsolete
```c
SMB_COM_COPY
SMB_COM_MOVE
SMB_COM_READ_MPX_SECONDARY
SMB_COM_SECURITY_PACKAGE_ANDX
SMB_COM_WRITE_MPX_SECONDARY
SMB_COM_GET_PRINT_QUEUE
```
10 Reserved but not implemented
```c
SMB_COM_CLOSE_AND_TREE_DISC
SMB_COM_FIND_NOTIFY_CLOSE
SMB_COM_IOCTL_SECONDARY
SMB_COM_NEW_FILE_SIZE
SMB_COM_QUERY_SERVER
SMB_COM_READ_BULK
SMB_COM_WRITE_BULK
SMB_COM_WRITE_BULK_DATA
```
备注：可以重点研究这些被抛弃和保留但未实现的数据包，有可能更容易出现漏洞。

比如客户端需要得到服务端共享的目录列表`\\server\c$`，需要进行以下交互过程：
```bash
Client --> SMB_COM_NEGOTIATE Request           --> Server
Client <-- SMB_COM_NEGOTIATE Response          <-- Server
Client --> SMB_COM_SESSION_SETUP_ANDX Request  --> Server
Client <-- SMB_COM_SESSION_SETUP_ANDX Response <-- Server
Client --> SMB_COM_TREE_CONNECT_ANDX Request   --> Server
Client <-- SMB_COM_TREE_CONNECT_ANDX Response  <-- Server
```

### SMB消息结构

SMB数据包在网络上既可以基于NetBIOS over TCP也可以直接基于TCP构建，这里先不解释两者的区别。单纯的SMB协议数据包格式如下：

|格式     |  长度  |
|--------|--------|
|SMB_header|a fixed 32-bytes|
|SMB_Parameters|a variable length parameter block |
|SMB_Data|a variable length data block|

````c
SMB_Header
{
    UCHAR  Protocol[4];
    UCHAR  Command;
    SMB_ERROR Status;
    UCHAR  Flags;
    USHORT Flags2;
    USHORT PIDHigh;
    UCHAR  SecurityFeatures[8];
    USHORT Reserved;
    USHORT TID;
    USHORT PIDLow;
    USHORT UID;
    USHORT MID;
}
```
上述一字节的Command用于定义已列举的10类SMB命令集合，比如0x72指的是SMB_COM_NEGOTIATE。无论是客户端向服务端发送的SMB_COM_NEGOTIATE request，还是服务端响应客户端的SMB_COM_NEGOTIATE response，Command都为0x72。
```c
SMB_Parameters
{
   UCHAR  WordCount;
   USHORT Words[WordCount] (variable);
}
```
注意USHORT大小为2字节，因此Words的大小为`2*WordCount`字节，和SMB_Data有区别。
```c
SMB_Data
{
   USHORT ByteCount;
   UCHAR  Bytes[ByteCount] (variable);
}
```
不同SMB命令的SMB_Parameters和SMB_Data内容也各不相同，比如SMB_COM_NEGOTIATE request数据包：
```c
SMB_Parameters
{
   UCHAR  WordCount;  //WordCount must be 0x0
}
SMB_Data
{
   USHORT ByteCount;
   Bytes
   {
     UCHAR Dialects[];
   }
}
```
只要按照每个SMB命令的数据包格式，自己也能构造特定的SMB命令。

## 0x02_漏洞原因分析

永恒之蓝漏洞最本质的原因在于对出现在`Transaction2 subcommands`和`NT_TRANSACT_CREATE subcommand`数据包中的SMB_FEA_LIST结构的错误解析。SMB_FEA_LIST用于发送一系列定义的SMB_FEA结构：
```c
SMB_FEA_LIST
{
  ULONG SizeOfListInBytes;
  UCHAR FEAList[];
}
```
其承载的SMB_FEA结构用于实现对文件拓展属性EA的name/value对进行编码的功能。
```c
SMB_FEA
{
  UCHAR      ExtendedAttributeFlag;
  UCHAR      AttributeNameLengthInBytes;
  USHORT     AttributeValueLengthInBytes;
  UCHAR      AttributeName[AttributeNameLengthInBytes + 1];
  UCHAR      AttributeValue[AttributeValueLengthInBytes];
}
```


永恒之蓝漏洞出现在`Transaction2 subcommands`上，该子命令集合主要用于客户端向服务端提交“文件枚举”、“查询和设置文件属性”、“DFS引用检索”等操作请求：
> The SMB_COM_TRANSACTION2 request is sent by a client to execute a specific operation of various types on the server. These operations include file enumeration, query and set file attribute operations, and DFS referral retrieval.

Transaction2命令的基本格式如下：
```c
SMB_Parameters
{
   UCHAR  WordCount;
   Words
   {
     USHORT TotalParameterCount;
     USHORT TotalDataCount;
     USHORT MaxParameterCount;
     USHORT MaxDataCount;
     UCHAR  MaxSetupCount;
     UCHAR  Reserved1;
     USHORT Flags;
     ULONG  Timeout;
     USHORT Reserved2;
     USHORT ParameterCount;
     USHORT ParameterOffset;
     USHORT DataCount;
     USHORT DataOffset;
	 UCHAR  SetupCount; // must be 0x01
     UCHAR  Reserved3;
     USHORT Setup[SetupCount]; //定义subcommand
   }
}
SMB_Data
{
   USHORT ByteCount;
   Bytes
   {
     UCHAR Name;
     UCHAR Pad1[];
     UCHAR Trans2_Parameters[ParameterCount];
     UCHAR Pad2[];
     UCHAR Trans2_Data[DataCount];
   }
}
```
其中SMB_Parameters中的2字节的Setup定义了各种各样的Transaction2子命令：

```c
TRANS2_OPEN2                0x0000
TRANS2_FIND_FIRST2          0x0001
TRANS2_FIND_NEXT2           0x0002
TRANS2_SET_FILE_INFORMATION 0x0008
```


一个完成


SMB协议数据包格式如下：



SMB_header

SMB_Parameters




搞清楚什么样的数据包





（1）复现与分析：


通过分析MS17-010 EternalBlue数据包，完成该漏洞的复现与分析，搞清楚什么样的数据包，什么顺序的数据包能够导致漏洞，搞清楚不同种类的SMB数据包与srv.sys和srvnet.sys函数处理流程的关系。


漏洞稳定重现，漏洞检测工具


（2）研究漏洞的利用：


如何通过布局内存池完成漏洞的利用


（3）KernelShellcode的编写：


在内核层如何完成一个完整的shellcode，具体需要实现什么功能。


需要实现的内核shellcode的功能：


（a）远程shellcode执行、（b）远程EXE新建进程执行、（c）远程DLL注入


（4）RCE批量扫描与利用框架：


开发一款可扩展的批量扫描与利用框架，类似于自定义TCP（send, 1, b'0000008554522d'）


（5）国内互联网检测与漏洞上报：


编写检测与利用工具，完成相关文档的整理，批量扫描国内互联网，完成该漏洞的研究。











## 原理分析





## 如何利用





## 内核shellcode





## 如何从内核中启动一个exe进程











### 参考资料





* [NSA Eternalblue SMB 漏洞分析](http://blogs.360.cn/blog/nsa-eternalblue-smb/)


* [MS17-010 SMB 远程命令执行漏洞利用分析](http://bbs.pediy.com/thread-217745.htm)








